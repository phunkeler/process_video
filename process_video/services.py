import logging
import os
from pathlib import Path
from typing import Optional
from urllib.parse import urlparse

import ffmpeg
import requests
from moviepy.editor import *
from PIL import Image
from pytube import YouTube
from requests_file import FileAdapter

from process_video.coordinate import Coordinate
from process_video.size import Size


class BaseService:
    def __init__(self) -> None:
        self.logger = logging.getLogger(
            f"{__name__}.{self.__class__.__name__}",
        )


class FileService(BaseService):
    def __init__(self) -> None:
        super().__init__()
        self._session = requests.Session()
        self._session.mount("file://", FileAdapter())
        self._output_path = Path(__file__).parent.resolve()

    def get_file(self, url: str) -> Optional[Path]:
        parsedUrl = urlparse(url)
        self.log_download(url)
        file = None

        if (
            "youtube.com" in parsedUrl.hostname.lower()
            and parsedUrl.path.lower() == "/watch"
        ):
            file = Path(
                YouTube(url)
                .streams.get_highest_resolution()
                .download(self._output_path)
            )
        else:
            response = self._session.get(url, stream=True, verify=False)
            if response.status_code == requests.codes.ok:
                fileName = os.path.basename(url)
                file = Path(self._output_path, fileName)
                out = open(file, "wb")
                for block in response.iter_content(1024):
                    if not block:
                        break
                    out.write(block)
                out.close()
        return file

    def compress_file(self, file: Path) -> None:
        newFile = file.with_name(f"{file.stem}_compressed{file.suffix}")
        stream = ffmpeg.input(str(file))
        stream = ffmpeg.output(stream, str(newFile), **{"c:v": "libx264"})
        ffmpeg.run(stream)
        self.replace_file(file, newFile)

    def replace_file(self, old: Path, new: Path) -> None:
        if old.is_file() and new.is_file():
            old.unlink()
            new.rename(old)

    def log_download(self, url: str):
        self.logger.info(f'Downloading "{url}".')


class ImageService(FileService):
    def __init__(self) -> None:
        super().__init__()

    def resize_image(self, file: Path, size: Size):
        newFile = file.with_name(f"{file.stem}_resized{file.suffix}")
        with Image.open(str(file)) as image:
            image.thumbnail(size.to_tuple())
            image.save(newFile)
            super().replace_file(file, newFile)


# TODO: moviepy offers it's own resize tool for resizing images. Can we use this instead of ffmpeg's?
class VideoService(FileService):
    def __init__(self) -> None:
        super().__init__()

    def overlay_image(self, video: Path, image: Path, coordinate: Coordinate) -> None:
        newVideo = video.with_name(f"{video.stem}_overlayed{video.suffix}")

        vidClip = VideoFileClip(str(video))
        overlay = (
            ImageClip(str(image), transparent=True)
            .set_duration(vidClip.duration)
            .set_position(coordinate.to_tuple())
        )
        # .resize(height=50) # if you need to resize...
        final = CompositeVideoClip([vidClip, overlay])
        final.write_videofile(str(newVideo))
        super().replace_file(video, newVideo)

    def apply_speed_ramp(self):
        # The below was generated by ChatGPT. Test it out!
        input_file = "input.mp4"
        output_file = "output.mp4"
        speed_factor = 2.0  # Speed factor (e.g., 2.0 for double speed)
        start_time = 10.0  # Start time of the speed ramp (in seconds)
        end_time = 20.0  # End time of the speed ramp (in seconds)

        # Load the video clip
        clip = VideoFileClip(input_file)

        # Split the clip into three parts: before, during, and after the speed ramp
        clip_before = clip.subclip(0, start_time)
        clip_during = clip.subclip(start_time, end_time)
        clip_after = clip.subclip(end_time, None)

        # Apply speed ramp effect to the during clip
        clip_during = clip_during.fx.speedx(factor=speed_factor)

        # Concatenate the clips together
        final_clip = concatenate([clip_before, clip_during, clip_after])

        # Write the final clip to the output file
        final_clip.write_videofile(output_file)
