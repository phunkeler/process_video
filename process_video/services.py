import logging
import os
from pathlib import Path
from typing import Optional
from urllib.parse import urlparse

import ffmpeg
import requests
from moviepy.editor import *
from PIL import Image
from pytube import YouTube
from requests_file import FileAdapter

from process_video.coordinate import Coordinate
from process_video.effects import (
    OverlayHandler,
    ResizeOverlayHandler,
    SpeedRampHandler,
    VideoEffectRequest,
)
from process_video.size import Size


class BaseService:
    def __init__(self) -> None:
        self.logger = logging.getLogger(
            f"{__name__}.{self.__class__.__name__}",
        )


class FileService(BaseService):
    def __init__(self) -> None:
        super().__init__()
        self._session = requests.Session()
        self._session.mount("file://", FileAdapter())
        self._output_path = Path(__file__).parent.resolve()

    def get_file(self, url: str) -> Optional[Path]:
        parsedUrl = urlparse(url)
        self.log_download(url)
        file = None

        if (
            "youtube.com" in parsedUrl.hostname.lower()
            and parsedUrl.path.lower() == "/watch"
        ):
            file = Path(
                YouTube(url)
                .streams.get_highest_resolution()
                .download(self._output_path)
            )
        else:
            response = self._session.get(url, stream=True, verify=False)
            if response.status_code == requests.codes.ok:
                fileName = os.path.basename(url)
                file = Path(self._output_path, fileName)
                out = open(file, "wb")
                for block in response.iter_content(1024):
                    if not block:
                        break
                    out.write(block)
                out.close()
        return file

    def compress_file(self, file: Path) -> None:
        newFile = file.with_name(f"{file.stem}_compressed{file.suffix}")
        stream = ffmpeg.input(str(file))
        stream = ffmpeg.output(stream, str(newFile), **{"c:v": "libx264"})
        ffmpeg.run(stream)
        self.replace_file(file, newFile)

    def replace_file(self, old: Path, new: Path) -> None:
        if old.is_file() and new.is_file():
            old.unlink()
            new.rename(old)

    def log_download(self, url: str):
        self.logger.info(f'Downloading "{url}".')


class ImageService(FileService):
    def __init__(self) -> None:
        super().__init__()

    def resize_image(self, file: Path, size: Size):
        newFile = file.with_name(f"{file.stem}_resized{file.suffix}")
        with Image.open(str(file)) as image:
            image.thumbnail(size.to_tuple())
            image.save(newFile)
            super().replace_file(file, newFile)


# TODO: moviepy offers it's own resize tool for resizing images. Can we use this instead of ffmpeg's?
class VideoService(FileService):
    def __init__(self) -> None:
        super().__init__()

    def overlay_image(self, video: Path, image: Path, coordinate: Coordinate) -> None:
        newVideo = video.with_name(f"{video.stem}_overlayed{video.suffix}")

        vidClip = VideoFileClip(str(video))
        overlay = (
            ImageClip(str(image), transparent=True)
            .set_duration(vidClip.duration)
            .set_position(coordinate.to_tuple())
        )
        # .resize(height=50) # if you need to resize...
        final = CompositeVideoClip([vidClip, overlay])

        final.write_videofile(str(newVideo))
        super().replace_file(video, newVideo)

        self.apply_speed_ramp(newVideo)

    def apply_speed_ramp(self, path: Path):
        # The below was generated by ChatGPT. Test it out!

        output_file = path.with_name(f"{path.stem}_speedramped{path.suffix}")
        speed_factor1 = -8.0  # Speed factor (e.g., 2.0 for double speed)
        start_time1 = 0.0  # Start time of the speed ramp (in seconds)
        end_time1 = 5.0  # End time of the speed ramp (in seconds)

        speed_factor2 = 1.0  # Speed factor (e.g., 2.0 for double speed)
        start_time2 = 5.0  # Start time of the speed ramp (in seconds)
        end_time2 = 7.0  # End time of the speed ramp (in seconds)

        speed_factor3 = -8.0  # Speed factor (e.g., 2.0 for double speed)
        start_time3 = 7.0  # Start time of the speed ramp (in seconds)
        end_time3 = 12.0  # End time of the speed ramp (in seconds)

        speed_factor4 = 1.0  # Speed factor (e.g., 2.0 for double speed)

        # Load the video clip
        clip = VideoFileClip(str(path))

        # Split the clip into three parts: before, during, and after the speed ramp
        clip1 = clip.subclip(0, end_time1)
        clip2 = clip.subclip(end_time1, end_time2)
        clip3 = clip.subclip(end_time2, end_time3)
        clip4 = clip.subclip(end_time3, None)

        # Apply speed ramp effect to the during clip
        clip1 = clip1.fx.speedx(factor=speed_factor1)
        clip2 = clip2.fx.speedx(factor=speed_factor2)
        clip3 = clip3.fx.speedx(factor=speed_factor3)
        clip4 = clip4.fx.speedx(factor=speed_factor4)

        # Concatenate the clips together
        final_clip = concatenate([clip1, clip2, clip3, clip4])

        # Write the final clip to the output file
        final_clip.write_videofile(output_file)


class VideoEffectService(BaseService):
    def __init__(self, image_service: ImageService) -> None:
        self.image_service = image_service
        super().__init__()

    def apply_effects(self, request: VideoEffectRequest) -> None:
        # Arrange chain of handlers and pass to first one
        resize_overlay_handler = ResizeOverlayHandler()
        overlay_handler = OverlayHandler()
        speedramp_handler = SpeedRampHandler()
        resize_overlay_handler.set_next(overlay_handler).set_next(speedramp_handler)
        final = resize_overlay_handler.handle(request)
        final.video_clip.write_videofile("output.mp4", threads=8)
        print("END")
